# HD44780

The **Hitachi HD44780** is the de-facto standard LCD controller for character-based displays (like 16×2, 20×4 LCD modules).
 It’s old, but still the most important display driver for hobby microcontrollers, including AVR (ATmega series).

This document covers **everything you need to actually use it** with AVR, from pins, to memory maps, to instructions, to timing, and AVR hookup.

------

## Pins & signals (14/16-pin modules)

Most HD44780 modules come in **14-pin** (no backlight) or **16-pin** (with backlight) DIP-style headers. Let’s break them down:

1. **VSS** → Ground (0V).
   - Connect to MCU ground.
2. **VDD** → Supply voltage (+5V typical, sometimes +3.3V tolerant).
   - Power input.
3. **VO** → Contrast control.
   - This controls the **voltage level applied to the LCD glass**, which affects how visible the pixels are.
   - If VO is close to VDD, the characters may become “washed out” (too faint).
   - If VO is close to VSS, the screen may go dark or filled with blocks.
   - Typically connected to the wiper of a **10k potentiometer** between VDD and VSS, so you can tune contrast by hand.
4. **RS** → Register Select.
   - 0 = Instruction register (commands).
   - 1 = Data register (characters).
5. **RW** → Read/Write.
   - 0 = Write to LCD (common).
   - 1 = Read from LCD (rare, but used for busy flag).
6. **E (Enable)** → Strobe.
   - High → Low pulse tells the LCD to latch the data/command.

7–14. **D0–D7** → Data bus.

- Can use all 8 (8-bit mode).
- Or only D4–D7 (4-bit mode).

1. **LEDA** → Backlight Anode (+).

- Connect to VDD through a suitable resistor.

1. **LEDK** → Backlight Cathode (–).

- Connect to VSS.

------

### Contrast vs Backlight — what’s the difference?

- **Contrast Control (VO)**
  - Adjusts the **LCD glass driving voltage**, which determines the darkness/visibility of the character pixels against the background.
  - Without proper contrast, the text may be invisible or just black boxes.
  - It affects how the liquid crystal molecules twist to block light, but it does **not** produce light itself.
- **Backlight (LEDA/K)**
  - Provides actual **light behind the LCD panel**.
  - HD44780 displays are **transmissive** or **transflective** — the characters themselves don’t emit light.
  - Without a backlight, you can still see the display in good ambient lighting (sunlight, desk lamp).
  - With a backlight, the display becomes readable in low light or dark environments.

👉 In short:

- **VO = controls the "contrast" of the dark text**.
- **Backlight = provides illumination so you can see it in the dark**.
- Both are independent: you need **contrast control** to make the characters visible, and **backlight** only if you want it lit.

------

## Memory map (DDRAM/CGRAM) & cursor addresses

The HD44780 is not a dumb framebuffer — it has two memory spaces:

- **DDRAM (Display Data RAM)**
  - Holds which **characters** are shown on the screen.
  - Each character cell on the LCD corresponds to **1 byte in DDRAM**.
  - A 16×2 LCD = 32 visible characters → 32 DDRAM addresses (plus padding).
  - Each DDRAM entry stores a **character code** (points into CGROM/CGRAM).
- **CGRAM (Character Generator RAM)**
  - Lets you define up to **8 custom glyphs** (5×8 pixel patterns).
  - Each glyph = 8 bytes.
  - Glyph codes = 0x00–0x07.

### Terms explained:

- **Line**: A row of text on the LCD (e.g., Line 1, Line 2).
- **Glyph**: The actual 5×8 pixel pattern representing a character.
- **DDRAM**: The table of characters currently on screen.
- **CGRAM**: User-defined storage for custom characters.

👉 Example: Writing ASCII code `0x41` (‘A’) into DDRAM doesn’t draw pixels directly — it fetches the ‘A’ glyph from the built-in font ROM.

------

## Instruction set (you’ll use these 95% of the time)

The HD44780 responds to **8-bit instructions** on the bus when `RS=0`.
 Datasheet uses binary mnemonics like `0b0011NFxx`. Let’s decode:

- `0b` → means binary literal.
- Each position is either:
  - `0` or `1` (fixed bit).
  - A letter (N, F, D, C, B…) = a **parameter bit**.
- `x` = don’t care.

### Key instructions (decoded):

- **Clear Display** → `0b00000001`
  - Clears DDRAM and resets cursor.
- **Return Home** → `0b00000010`
  - Cursor back to address 0, no DDRAM clear.
- **Entry Mode Set** → `0b000001IS`
  - I = Increment/decrement cursor.
  - S = Shift display on each char.
- **Display Control** → `0b00001DCB`
  - D = Display on/off.
  - C = Cursor on/off.
  - B = Cursor blink on/off.
- **Function Set** → `0b0011NFxx`
  - N = Number of lines (0=1 line, 1=2 lines).
  - F = Font (0=5×8, 1=5×10).
  - `xx` are don’t-care.

👉 So those cryptic codes are just **binary templates** with configurable bits.

------

### Instruction set (detailed with timing)

Here are the **most important opcodes** you’ll use, with meaning and execution time:

- **Function Set** → `0b0011NFxx`
  - DL = Data length (1=8-bit, 0=4-bit).
  - N = Number of lines (0=1 line, 1=2 lines).
  - F = Font (0=5×8, 1=5×10).
  - Execution: ~37 µs.
- **Display On/Off Control** → `0b00001DCB`
  - D = Display on/off.
  - C = Cursor on/off.
  - B = Blink cursor on/off.
  - Execution: ~37 µs.
- **Entry Mode Set** → `0b000001IS`
  - I/D = Increment (1) or decrement (0) cursor position after each character write.
  - S = Shift entire display after each character write (rarely used).
  - Execution: ~37 µs.
- **Clear Display** → `0b00000001`
  - Clears DDRAM (fills with spaces).
  - Sets address counter (AC) = 0.
  - Execution: ~1.52 ms.
- **Return Home** → `0b0000001x`
  - Sets AC = 0.
  - Cancels display shift.
  - Execution: ~1.52 ms.
- **Set DDRAM Address** → `0b1AAAAAAA`
  - AAAAAAA = 7-bit DDRAM address (cursor position).
  - Used to set where the next character goes.
  - Execution: ~37 µs.
- **Set CGRAM Address** → `0b01AAAAAA`
  - AAAAAA = 6-bit CGRAM address (custom character memory).
  - Used when writing custom glyphs.
  - Execution: ~37 µs.

📌 Note: **AC (Address Counter)** is the internal pointer that tracks where the next read/write happens. It is automatically updated after character writes.

⏱️ Execution times (`~37 µs` or `~1.52 ms`) assume fOSC ≈ 270 kHz (internal LCD clock).

------

## Power-on & initialization (the essential sequences)

Unlike modern chips, the HD44780 **does not self-initialize**.
 You must send a **startup sequence** after power-on.

- Why? On power-up, the bus width (4/8-bit), font, and lines are undefined.

### How to do it

- **Yes, you must do this in your AVR code.**
- Common approach:
  1. Wait ~15ms after power is stable.
  2. Send the “Function Set” command 3 times (special reset sequence).
  3. Switch to chosen mode (4-bit or 8-bit).
  4. Configure display control & entry mode.

👉 Example (AVR pseudocode for 4-bit mode):

```
lcd_cmd(0x33); // special reset
lcd_cmd(0x32); // set to 4-bit mode
lcd_cmd(0x28); // function set: 4-bit, 2 line, 5x8 font
lcd_cmd(0x0C); // display ON, cursor OFF, blink OFF
lcd_cmd(0x06); // entry mode: increment, no shift
lcd_cmd(0x01); // clear display
_delay_ms(2);
```

------

## Read/write timing you actually need to meet

Datasheets specify many `t_` parameters, which are **timing constraints**:

- `t_AS` = Address setup time (RS/RW stable before E goes high).
- `t_DSW` = Data setup time (data stable before E falls).
- `t_H` = Hold time (data stable after E falls).
- `t_PWEH` = E pulse width (how long E must stay high).
- `t_C` = Cycle time (minimum time between two Enable pulses).

👉 In practice:

- Your AVR code just needs **short `_delay_us()` between operations**.
- Example:
  - Write cycle: ~40 µs.
  - Clear/Home: ~1.5–2 ms.

If you poll the **busy flag (BF)** on D7, you can skip fixed delays.

------

## Addressing recipes (drop-in)

Each DDRAM address maps to a display position. But not linearly!
 For a **16×2 LCD**:

- Line 1 → DDRAM 0x00–0x0F
- Line 2 → DDRAM 0x40–0x4F

For a **20×4 LCD** (two controller chips inside):

- Line 1 → DDRAM 0x00–0x13
- Line 2 → DDRAM 0x40–0x53
- Line 3 → DDRAM 0x14–0x27
- Line 4 → DDRAM 0x54–0x67

👉 Recipe:
 To move cursor → send `0b10000000 | addr` with the target DDRAM address.
 Example: `lcd_cmd(0x80 | 0x40)` → moves to start of Line 2.

------

## Hardware hookup (AVR)

Typical **4-bit mode wiring** (saves pins):

- LCD D4–D7 → AVR PORTx pins.
- LCD RS, E → AVR pins.
- LCD RW → Tie to GND (write-only).
- VSS → GND.
- VDD → +5V.
- VO → middle of 10k pot between +5V and GND.
- LEDA → +5V through 220Ω resistor.
- LEDK → GND.

👉 AVR C library drivers usually wrap this. Example:

```
#define LCD_PORT PORTD
#define LCD_DDR  DDRD
#define RS PD0
#define EN PD1

void lcd_pulse() {
    LCD_PORT |= (1<<EN);
    _delay_us(1);
    LCD_PORT &= ~(1<<EN);
}

void lcd_cmd(uint8_t cmd) {
    LCD_PORT &= ~(1<<RS); // RS=0
    // send upper nibble
    LCD_PORT = (LCD_PORT & 0x0F) | (cmd & 0xF0);
    lcd_pulse();
    // send lower nibble
    LCD_PORT = (LCD_PORT & 0x0F) | ((cmd<<4) & 0xF0);
    lcd_pulse();
    _delay_us(40); // wait
}
```

------

## Custom characters (CGRAM)

The **CGRAM** lets you define up to **8 user glyphs**.
 Each glyph is a **5×8 dot matrix** (5 columns × 8 rows).

- Each row = 1 byte, but only lower 5 bits are used.
- Example: To draw a smiley face:

```
Row data: 
0b00000
0b01010
0b01010
0b00000
0b00000
0b10001
0b01110
0b00000
```

- Store in CGRAM using `Set CGRAM Address` command (`0b01xxxxxx`).
- Then write row data sequentially.
- Display it by writing character code `0x00–0x07` into DDRAM.

👉 Recipe:

- Load custom char at CGRAM address 0.
- Then writing `0x00` into DDRAM will display it.